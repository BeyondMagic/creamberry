#!/usr/bin/env sh
#
# Description
#   Load MPD info every time MPD updates
# 
# Dependencies:
#   mpd
#     mpc
#
# BeyondMagic  GPL3 LICENSE  2021

song_format() {
  
               info=$(mpc)
               song=$(echo "$info" | head -n 1)
        song_length=${#song}
  max_length_scroll="$3"

   start_st="%%{F$1}"
  middle_st="%%{F$2}"

  [ ! -n $(pidof mpd) ] && {

    # If the return value is not 0, then echo nothing, since mpd is not running
    exit

  } || {

      # mpd is running, so find out if it's playing or paused and echo the
      # corresponding glyph
      echo "$info" | grep -q "playing" && {

        sleep 0

      } || {

        printf "paused" &
        exit

      }

  }

  case "$max_length_scroll" in
    ''|*[!0-9]*)
      sleep 0
    ;;
    *)
      [ "$song_length" -ge "$max_length_scroll" ] && {

        songd="$(expr substr "$song" "$offset" "$max_length_scroll")"
        [ "$songd" = "" ] || song="$songd"

      }
    ;;
  esac

  # Parse the info to get the progress in %
  #   total=$(echo "$info" | sed -r "s/duration //;t;d")
  #   progr=$(echo "$info" | sed -r "s/position //;t;d")
  #   perc=$(awk -v n="$total" -v m="$progr" 'BEGIN{ print int(( m/n )*100) }')
  perc=$(echo "$info" | grep -oie "([[:digit:]]*%)" | tr '%' ' ' | tr '(' ' ' | tr ')' ' ')
  song_length=${#song}
  perc_chr=$(awk -v n="$song_length" -v m="$perc" 'BEGIN{ print int( n*(m/100)) }')

  printf "$start_st$(expr substr "$song" 1 $perc_chr)$middle_st$(expr substr "$song" $(($perc_chr + 1)) $song_length)" &
    
}

# Run formated song
_run_song() {

  song="$(song_format "$first_running_song_name" "$second_running_song_name" "$limit_extra_length")"

  # dance loop
  #  [ "$dance" = "$dance_r" ] && dance="$dance_l" || dance="$dance_r"
 
	playlist="$(mpc playlist)"
   current="$(mpc current)"
    before="$(mpc playlist | grep -B1 "$current" | head -n 1)"
     after="$(mpc queued)"

  # No before?
  [ "$before" ] || before=$(mpc playlist | grep -B1 -Ps "[-$current]" | head -n 1)

  # If this is the first song of the playlist, then just outputs nothing as before
	[ "$(echo "$playlist" | head -n1)" = "$current" ] && before="" || {

    # Reduce length if it's bigger than 40 characters
    [ ${#before} -gt $song_limit ] && before="$(echo "$before" | cut -c -$song_limit)..."

  }

  [ "$after" ] && after="$(echo "$after" | cut -c -$song_limit)..."

  echo 'M' "%{T1}%{F$neighbors_fg}$before  %{T2}%{F$first_running_song_name}$song  %{T1}%{F$neighbors_fg}$after%{F-}" &

}

# This function is called to continue the loop throughout the song
#   It will be stopped/killed when MPD is stopped
#   Funny enough the same script being looped here
#   Is the one being used to stop this loop.
_loop_song() {
  
  while :; do

    mpc current --wait >/dev/null 2>&1 || exec sleep 0

    # notify song
    $origin/../mpd/song

    _run_song

  done &

  while :; do
  
    _run_song
    sleep 1

  done &

}

# This function will kill all the children and subchildren
_kill_children() {

  pid="$(pgrep -P $$ | tail -n1)"
  list_pid="$(pgrep -P $pid | tail -n1)" 
  
  pkill -P "$pid"
  pkill -9 -f "mpc current --wait"
  
}

# This function is the main one and will get the information of MPD
#   It uses "mpc idleloop" method to gather MPD updates
#   This can be further simplified to only use MPD protocol,
#   however you need to edit the source code... which I'm
#   not with the will to do.
_music() {
  
  [ "$1" ] && origin="$1"

  mpc idleloop | \
    while IFS=$'\n' read -r new_change && read -r double_change; do

    song="$(song_format "$first_running_song_name" \
      "$second_running_song_name" "$limit_extra_length")"

    # if paused
    #   If paused, then stop loop function
    [ "$song" = "paused" ] && {

     _kill_children 
      echo 'M' "%{F$second_running_song_name} $extra_icon_paused %{F-}"

    # if running
    #   If running, then continues the loop function
    } || {
      
      [ "$new_change" = 'mixer' ] && [ "$double_change" = 'mixer' ] && {

        #printf "Volume only\n"
        sleep 0

      } || {

        _kill_children
        _loop_song

      }
    
    }

  done

  echo 'M' "- : •́ ◇ •̀ : -"; sleep 5
  exec "$origin/top_bar/_song" "$origin"

}

[ "$1" = "run" ] && {

  origin="$(cd -- "$(dirname "$0")" >/dev/null 2>&1 && pwd -P)"/..
  . "$origin"/config
  _music "$origin"

}
